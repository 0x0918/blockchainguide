![image-20201207083425581](https://tva1.sinaimg.cn/large/0081Kckwgy1glezr2x49mj314s0fgjt9.jpg)

> **关于无状态以太坊计划的注释：** 由于所有贡献者都已经适应了怪异的时间表，因此研究活动在2020年下半年有所放缓（这是可以理解的）。但是随着生态系统逐渐接近宁静和Eth1 / Eth2合并，无状态以太坊的工作将变得越来越重要和有意义。预计在未来几周内将有更多实质性的无状态以太坊回顾。

让我们再回顾一次：无状态以太坊的最终目标是消除以太坊节点始终保留完整的更新状态Trie的副本的*要求*，而允许状态变化依赖证明某笔特定交易正在进行有效更改的数据量（小得多）。这样做解决了以太坊的一个主要问题。迄今为止，只有改进的客户端软件才能进一步解决这个问题：[状态增长](https://blog.ethereum.org/2019/12/30/eth1x-files-state-of-stateless-ethereum/)。

无状态以太坊所需的Merkle证明称为“见证”，它通过提供到达新的有效状态根所需的所有未*更改的*中间哈希来证明状态改变。从理论上来说，见证人要比完整的以太坊状态（同步最多需要6个小时）要小得多，但仍然比区块（要在短短几秒钟内传播到整个网络）要*大得多*。因此，充分利用证人的规模对于使无状态以太坊达到最低可行效用至关重要。

就像以太坊状态本身一样，证人的许多额外（数字）权重都来自智能合约代码。如果交易调用特定合同，则见证人默认情况下需要在见证人中*完整*包含合同字节码。代码合并是减少见证人中智能合约代码负担的一种通用技术，因此合约调用只需要包含他们“接触”的代码位即可证明其有效性。仅通过这种技术，我们就可以看到见证人的大量减少，但是在将智能合约代码分解为字节大小的块时，有很多细节需要考虑。

## 什么是字节码？

拆分合同字节码时需要考虑一些折衷。我们最终需要问的问题是“代码块有多大？” –但现在，让我们来看一个非常简单的智能合约中的一些实际字节码，以了解它是什么：

```solidity
pragma solidity >=0.4.22 <0.7.0;

contract Storage {

    uint256 number;

    function store(uint256 num) public {
        number = num;
    }

    function retrieve() public view returns (uint256){
        return number;
    }
}
```

编译此简单的存储合同后，它将变成用于在EVM内部运行的机器代码。在这里，您可以看到与上面显示的相同的简单存储协定，但已被遵从各个EVM指令（操作码）：

> PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH1 0x32 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x2E64CEC1 EQ PUSH1 0x37 JUMPI DUP1 PUSH4 0x6057361D EQ PUSH1 0x53 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x3D PUSH1 0x7E JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x7C PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH1 0x67 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH1 0x87 JUMP JUMPDEST STOP JUMPDEST PUSH1 0x0 DUP1 SLOAD SWAP1 POP SWAP1 JUMP JUMPDEST DUP1 PUSH1 0x0 DUP2 SWAP1 SSTORE POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 DUP13 PUSH7 0x1368BFFE1FF61A 0x29 0x4C CALLER 0x1F 0x5C DUP8 PUSH18 0xA3F10C9539C716CF2DF6E04FC192E3906473 PUSH16 0x6C634300060600330000000000000000

如[前一篇文章所述](https://blog.ethereum.org/2020/07/28/the-1x-files-ghost-in-the-stack-machine/)，这些操作码指令是EVM堆栈体系结构的基本操作。它们定义了简单的存储协定及其包含的所有功能。您可以在[Remix IDE中](https://remix.ethereum.org/)找到该合同作为solidity合同示例之一（请注意，上面的机器代码是*已经部署后*的storage.sol的示例，而不是Solidity编译器的输出，它将具有一些额外的“自举”操作码）。如果您不专心，想象一台物理堆栈机器在操作码卡上进行逐步计算，那么在移动堆栈的模糊中，您几乎可以看到Solidity合同中列出的功能概述。

每当合约收到消息调用时，此代码就会在每个以太坊节点内运行，以验证网络上的新区块。为了今天在以太坊上提交有效的交易，需要一份合同字节码的完整副本，因为从头到尾运行该代码是获取（确定性）输出状态和相关散列的唯一方法。

请记住，无状态以太坊旨在改变这一要求。假设您要做的就是调用函数`retrieve()`，仅此而已。描述该函数的逻辑只是整个协定的一个子集，在这种情况下，EVM实际上仅需要两个操作码指令[基本块](https://en.wikipedia.org/wiki/Basic_block)才能返回所需的值：

> PUSH1 0x0 DUP1 SLOAD SWAP1 POP SWAP1 JUMP,
>
> JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN

在无状态范式中，就像见证人提供了未触及状态的缺失哈希值一样，见证人还应该为未执行的机器代码片断提供缺失的哈希值，因此无状态客户端仅需要其正在执行的合同的一部分。

## 守则的见证

以太坊中的智能合约生活在与外部账户相同的地方：就像巨大的单根状态树中的叶子节点一样。合同在许多方面与人类使用的外部拥有的帐户没有什么不同。他们有一个地址，可以提交交易，并持有以太币和任何其他代币的余额。但是合同帐户是特殊的，因为它们必须包含自己的程序逻辑（代码）或其哈希。另一个与之相关的Merkle-Patricia Trie称为“`storageTrie`保留” ，它保留了有效合同在执行过程中用于开展业务的任何变量或持久状态。

![image-20201207083635782](https://tva1.sinaimg.cn/large/0081Kckwgy1glezta5m3wj316g0h0jzn.jpg)

该见证程序可视化效果很好地了解了代码默化在减小见证程序大小方面的重要性。看到那巨大的彩色方块，它比trie中的所有其他元素大多少？这是一份完整的智能合约字节码。

`storageTrie`紧挨着它并在其下方的是中的持久状态，例如ERC20余额映射或ERC721数字商品所有权清单。由于这是见证人的示例，而不是完整状态的快照，因此这些示例也主要由中间哈希组成，并且仅包括无状态客户端证明下一个块所需的更改。

代码merkleization的目的是拆分大量的代码，并将`codeHash`以太坊帐户中的字段替换为另一个Merkle Trie的根，恰当地命名为`codeTrie`。

## 值钱的哈希值

让我们看一下[以太坊工程组视频](https://youtu.be/44PEl-GIlmw?t=852)中的一个示例，[该视频](https://youtu.be/44PEl-GIlmw?t=852)分析了使用[ERC20令牌](https://docs.openzeppelin.com/contracts/3.x/erc20)合同的一些代码分块方法。由于您听说过的许多令牌都是根据ERC-20标准制成的，因此这是理解代码混合的良好现实环境。

由于字节码长且不规则，因此我们使用一个简单的速记方式，即用`.`or`X`字符替换四个字节的代码（8个十六进制字符）， 后者代表执行特定功能所需的字节码（在示例中，该`ERC20.transfer()`功能为整个使用）。

在ERC20示例中，调用该`transfer()`函数使用的时间少于整个智能合约的一半：

> XXX.XXXXXXXXXXXXXXXXXX..........................................
> .....................XXXXXX.....................................
> ............XXXXXXXXXXXX........................................
> ........................XXX.................................XX..
> ......................................................XXXXXXXXXX
> XXXXXXXXXXXXXXXXXX...............XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
> XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..................................
> .......................................................XXXXXXXXX
> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX..................................X
> XXXXXXXX........................................................
> ....

如果我们想将代码分成64个字节的块，则执行无状态`transfer()`事务所需的41个块中只有19个需要执行，其余所需数据则来自见证人。

> |XXX.XXXXXXXXXXXX|XXXXXX..........|................|................
> |................|.....XXXXXX.....|................|................
> |............XXXX|XXXXXXXX........|................|................
> |................|........XXX.....|................|............XX..
> |................|................|................|......XXXXXXXXXX
> |XXXXXXXXXXXXXXXX|XX..............|.XXXXXXXXXXXXXXX|XXXXXXXXXXXXXXXX
> |XXXXXXXXXXXXXXXX|XXXXXXXXXXXXXX..|................|................
> |................|................|................|.......XXXXXXXXX
> |XXXXXXXXXXXXXXXX|XXXXXXXXXXXXX...|................|...............X
> |XXXXXXXX........|................|................|................
> |....

将其与32字节分块方案中的81个块中的31个进行比较：

> |XXX.XXXX|XXXXXXXX|XXXXXX..|........|........|........|........|........
> |........|........|.....XXX|XXX.....|........|........|........|........
> |........|....XXXX|XXXXXXXX|........|........|........|........|........
> |........|........|........|XXX.....|........|........|........|....XX..
> |........|........|........|........|........|........|......XX|XXXXXXXX
> |XXXXXXXX|XXXXXXXX|XX......|........|.XXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX
> |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXX..|........|........|........|........
> |........|........|........|........|........|........|.......X|XXXXXXXX
> |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXX...|........|........|........|.......X
> |XXXXXXXX|........|........|........|........|........|........|........
> |....

从表面上看，较小的块似乎比较大的块更有效率，因为*大部分为空的*块的频率较低。但是在这里我们需要记住，未使用的代码也有代价：每个未执行的代码块都被*固定大小*的哈希替换。较小的代码块意味着未使用的代码具有更多的哈希，这些哈希每个可能多达32个字节（或最小为8个字节）。您可能会在此时惊呼“嗨！如果代码块的哈希值是标准的32字节大小，那么如何用32字节的哈希值替换32字节的代码！

回想一下，合同代码是*merkleized的*，这意味着所有散列都链接到了`codeTrie`-我们需要验证其块的根哈希。在这种结构中，任何*顺序的*未执行块都仅需要一个哈希，无论有多少个哈希。就是说，一个散列可以代表一个可能很大的分支，其中在序列化散列化的代码特里上要有顺序的块散列，只要编码执行不需要它们。

## 我们必须收集其他数据

我们一直在得出的结论有点反高潮：理论上没有用于代码混合的“最佳”方案。固定代码块和哈希值的大小等设计选择**取决于有关“真实世界”的数据**。每个智能合约的融合都会有所不同，因此研究人员必须选择能够为观察到的主网活动提供最大效率收益的格式。到底是什么意思？

![image-20201207083746744](https://tva1.sinaimg.cn/large/0081Kckwgy1glezuixsloj314k07owg4.jpg)

可以表明代码Merkleization方案效率高的一件事是*Merkleization开销*，它回答了以下问题：“在该见证人中包含了超出执行代码的多少额外信息？”

我们已经使用由Consensys的TeamX研究团队的Horacio Mijail开发[的专用工具](https://github.com/ConsenSys/code_merklization_of_traces)收集[了](https://github.com/ConsenSys/code_merklization_of_traces)[一些令人鼓舞的结果](https://ethresear.ch/t/optimal-chunking-size-for-code-merklization/8185)，显示出的开销只有25％-一点都不差！

简而言之，数据表明，较小的块大小通常比较大的块更有效，尤其是在使用较小的哈希（8字节）的情况下。但是，这些早期数字绝不是全面的，因为它们仅代表了大约100个最新区块。
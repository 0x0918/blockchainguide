> 死磕以太坊源码分析之区块和交易广播

## 广播区块

广播区块的入口在`pm.minedBroadcastLoop()`,进入到`BroadcastBlock`,这里的参数为`bool`值，如果传入的为true，则将区块block和总难度td发送给一部分节点，节点数为根号n；如果传入的为false，则将区块的hash发送给所有的节点。**需要注意的是两个广播函数都执行**，我们先来看一下这两个部分执行的框架图：



进入到`true`分支：**代表只传播区块给一部分节点**

①：首先计算一个临时的TD

```go
if parent := pm.blockchain.GetBlock(block.ParentHash(), block.NumberU64()-1); parent != nil {
			td = new(big.Int).Add(block.Difficulty(), pm.blockchain.GetTd(block.ParentHash(), block.NumberU64()-1))
		} 
```

②：发送块到peers的子集

对节点数进行开方，16开方得4，然后取前4个节点。

```GO
transferLen := int(math.Sqrt(float64(len(peers))))
		if transferLen < minBroadcastPeers {
			transferLen = minBroadcastPeers
		}
		if transferLen > len(peers) {
			transferLen = len(peers)
		}
		transfer := peers[:transferLen]
		for _, peer := range transfer {
			peer.AsyncSendNewBlock(block, td) // 块传播
		}
```

执行完之后直接return出去，再次执行此函数，此时不会走ture分支，直接判断判断本地是否有区块，如果有则发送区区块哈希给剩下的节点，如果没有，则不做发送哈希的操作。

> 如果本地存在这个要广播的区块(很可能就是出块节点，或者接受块的节点已经插入到区块链中),那就还要像其他没有被广播到区块的节点发送区块哈希。

![image-20201125150810051](https://tva1.sinaimg.cn/large/0081Kckwgy1gl1fp0u7e3j31bw0hkthh.jpg)

> 如果本地不存在这个要广播的区块哈希(应该是还没接收到区块或者区块哈希的节点)，那它只要向它的节点列表里发送区块即可。

![image-20201125151546035](https://tva1.sinaimg.cn/large/0081Kckwgy1gl1fwwxfh2j31bi0e4tfv.jpg)

--------

接下来就是重点分析`AsyncSendNewBlock`和`AsyncSendNewBlockHash`两个函数了。

### AsyncSendNewBlock

> 发送块到需要广播的节点的广播队列中

```GO
select {
	case p.queuedProps <- &propEvent{block: block, td: td}:
		p.knownBlocks.Add(block.Hash())
		for p.knownBlocks.Cardinality() >= maxKnownBlocks {
			p.knownBlocks.Pop()
		}
```

这里的`queuedProps`是用来存放要广播的块的队列，同时，要把广播的块标记为已知，还不能超过1024（**maxKnownBlocks**）个。超过就会弹出队列第一个`propEvent()` 。接下来就是处理队列中的块了。

在`eth/peer.go`中，有个专门处理广播的循环`brodcast`

```go
func (p *peer) broadcast() {
	for {
		select {
		case txs := <-p.queuedTxs:
			if err := p.SendTransactions(txs); err != nil {
				return
			}
			p.Log().Trace("Broadcast transactions", "count", len(txs))

		case prop := <-p.queuedProps:
			if err := p.SendNewBlock(prop.block, prop.td); err != nil {
				return
			}
			p.Log().Trace("Propagated block", "number", prop.block.Number(), "hash", prop.block.Hash(), "td", prop.td)

		case block := <-p.queuedAnns:
			if err := p.SendNewBlockHashes([]common.Hash{block.Hash()}, []uint64{block.NumberU64()}); err != nil {
				return
			}
			p.Log().Trace("Announced block", "number", block.Number(), "hash", block.Hash())

		case <-p.term:
			return
		}
	}
}
```

> 广播新块到远程节点

```go
p.SendNewBlock(prop.block, prop.td);
```

远程节点收到块后同样也会标记哈希存入队列，并且不会超过最大，同时发送一个`NewBlockMsg`，`msgcode`为`0x07`,同时数据会被RLP编码。

```go
p.knownBlocks.Add(block.Hash())
	for p.knownBlocks.Cardinality() >= maxKnownBlocks {
		p.knownBlocks.Pop()
	}
	return p2p.Send(p.rw, NewBlockMsg, []interface{}{block, td})
```

```go
func Send(w MsgWriter, msgcode uint64, data interface{}) error {
	size, r, err := rlp.EncodeToReader(data)
	if err != nil {
		return err
	}
	return w.WriteMsg(Msg{Code: msgcode, Size: uint32(size), Payload: r})
}
```

接下来就是处理这个`NewBlockMsg`了。在`eth/handler.go`里有个`handleMsg`是专门处理消息的，找到对应的消息类型，查看代码：

```go
case msg.Code == NewBlockMsg:
		var request newBlockData // 接收消息并解码被广播过来的块
		if err := msg.Decode(&request); err != nil {
			return errResp(ErrDecode, "%v: %v", msg, err)
		}
		if err := request.sanityCheck(); err != nil {
			return err
		}
		request.Block.ReceivedAt = msg.ReceivedAt
		request.Block.ReceivedFrom = p    // P为发送广播块的节点

		p.MarkBlock(request.Block.Hash())
		pm.fetcher.Enqueue(p.id, request.Block) // fetcher 模块导入远程节点发过来的区块

		var (
			trueHead = request.Block.ParentHash()
			trueTD   = new(big.Int).Sub(request.TD, request.Block.Difficulty())
		)
		if _, td := p.Head(); trueTD.Cmp(td) > 0 {
			p.SetHead(trueHead, trueTD)
      
			currentBlock := pm.blockchain.CurrentBlock()
			if trueTD.Cmp(pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())) > 0 {
				go pm.synchronise(p)
			}
		}
```

主要做了以下几件事：

1. 接收消息并解码被广播过来的块
2. 校验区块头
   - 区块头里的高度不能太高
   - 区块头里的难度不能太大
   - 区块头里的extra字段不能超过100*1024字节
3. 通过`fetcher`模块将广播过来的块导入到本地区块链
4. 🚩TODO

------

### AsyncSendNewBlockHash

广播哈希的过程跟广播区块的过程非常的类似，直接跳转到处理`NewBlockHashesMsg`:

```GO
var announces newBlockHashesData
		if err := msg.Decode(&announces); err != nil {
			return errResp(ErrDecode, "%v: %v", msg, err)
		}
		// Mark the hashes as present at the remote node
		// 将hash 标记存在于远程节点上
		for _, block := range announces {
			p.MarkBlock(block.Hash)
		}
		//检索所有未知哈希
		unknown := make(newBlockHashesData, 0, len(announces))
		for _, block := range announces {
			if !pm.blockchain.HasBlock(block.Hash, block.Number) {
				unknown = append(unknown, block)
			}
		}
		for _, block := range unknown {
			pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies)
		}
```

1. 将哈希标记在远程节点上
2. 在本地检索远程节点发过来的哈希，找不到的话就都存入到`Unkown`里面,然后调用`fetcher.Notify`,注意这里有两个回调函数`p.RequestOneHeader`,`p.RequestBodies`,是用来再发送消息给远程节点获取哈希的`header`和`body`的.

> p.RequestOneHeader



## 广播交易